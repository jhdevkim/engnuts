#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "RAMNAND.h"
#include "SPFTL.h"
#include "MAINSIM.h"

void viewstatic_per_req(void)
{
	extern STATISTICS statics;

	printf("%d %d %d %d %d\n", statics.host_sectors, statics.meta_ftl_context_count, statics.meta_block_info_count, statics.meta_page_map_count, statics.num_usr_gc_cnt);
/*
	printf("host sectors written:\t%d\n", statics.host_sectors);

	printf("GXT\tPBT\tPMT\tGXTPT0\tGXTPT1\tPBT_V\tPMT_V\tGXTGC\tPBTGC\tPMTGC\tUSRGC\tUSRPG\tUSRGCPG:\n" \
		"%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
		statics.meta_ftl_context_count,
		statics.meta_block_info_count,
		statics.meta_page_map_count,
		statics.meta_ftl_0_block_write_page_count,
		statics.meta_ftl_1_block_write_page_count,
		statics.meta_block_valid,
		statics.meta_page_valid,
		statics.num_gxt_gc_cnt,
		statics.num_pbt_gc_cnt,
		statics.num_pmt_gc_cnt,
		statics.num_usr_gc_cnt,
		statics.usr_page_cnt,
		statics.usr_gc_page_cnt);
		*/
}

void viewstatics(void)
{
	extern STATISTICS statics;

	printf("host sectors written:\t%d\n",statics.host_sectors);

	printf("GXT\tPBT\tPMT\tGXTPT0\tGXTPT1\tPBT_V\tPMT_V\tGXTGC\tPBTGC\tPMTGC\tUSRGC\tUSRPG\tUSRGCPG:\n" \
			"%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
			statics.meta_ftl_context_count,
			statics.meta_block_info_count,
			statics.meta_page_map_count,
			statics.meta_ftl_0_block_write_page_count,
			statics.meta_ftl_1_block_write_page_count,
			statics.meta_block_valid,
			statics.meta_page_valid,
			statics.num_gxt_gc_cnt,
			statics.num_pbt_gc_cnt,
			statics.num_pmt_gc_cnt,
			statics.num_usr_gc_cnt,
			statics.usr_page_cnt,
			statics.usr_gc_page_cnt);

	printf("\nErase\n");

	printf("GXT_E PBT_E PMT_E 0BLK 1BLK:\n%d\t%d\t%d\t%d\t%d\n",
				statics.meta_ftl_context_erase_8,
				statics.meta_block_info_erase_8,
				statics.meta_page_map_erase_8,
				statics.meta_ftl_0_block_erase,
				statics.meta_ftl_1_block_erase);

#if ((FTL_TYPE & FTL_SPFTL_MIXED) || (FTL_TYPE & FTL_SPFTL_LOGGING))
	printf("GXT4\tPBT4\tPMT4\tGXTPT0\tGXTPT1\tPBT_V\tPMT_V\tGXTGC\tPBTGC\tPMTGC\tUSRGC\tUSRPG\tUSRGCPG:\n" \
		"%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
		statics.meta_ftl_context_count_4,
		statics.meta_block_info_count_4,
		statics.meta_page_map_count_4,
		statics.meta_ftl_0_block_write_page_count,
		statics.meta_ftl_1_block_write_page_count,
		statics.meta_block_valid_4,
		statics.meta_page_valid_4,
		statics.num_gxt_gc_cnt,
		statics.num_pbt_gc_cnt,
		statics.num_pmt_gc_cnt,
		statics.num_usr_gc_cnt,
		statics.usr_page_cnt,
		statics.usr_gc_page_cnt);

	printf("SP: GXT_E PBT_E PMT_E 0BLK 1BLK:\n%d\t%d\t%d\t%d\t%d\n",
		statics.meta_ftl_context_erase_4,
		statics.meta_block_info_erase_4,
		statics.meta_page_map_erase_4,
		statics.meta_ftl_0_block_erase,
		statics.meta_ftl_1_block_erase);
#endif

	printf("\nNAND\n");

	printf("tR tProg tErase tDMA:\n%d\t%d\t%d\t%d\n",
		statics.nand_tR,
		statics.nand_tProg,
		statics.nand_tErase,
		statics.nand_tDMA);

	printf("\n\n");
	printf("LPN statics\n");
	printf("2KB: %d, 4KB: %d, 8KB: %d\n", statics.lpn_check_group[0], statics.lpn_check_group[1], statics.lpn_check_group[2]);
	printf("\n\n");

//	printf("\nDetail\n");
//	printf("Meta ftl context	: %d\n", statics.meta_ftl_context_count);
//	printf("Meta valid context	: %d\n", statics.meta_context_valid);
//	printf("Meta val 4 context	: %d\n", statics.meta_context_valid_4);
//	printf("Meta plc 4 context	: %d\n", statics.meta_sub_page_context_count);
//
//	printf("Meta block infos	: %d\n", statics.meta_block_info_count);
//	printf("Meta valid cp block	: %d\n", statics.meta_block_valid);
//	printf("Meta val 4 block	: %d\n", statics.meta_block_valid_4);
//
//	printf("Meta page maps		: %d\n", statics.meta_page_map_count);
//	printf("Meta valid cp page	: %d\n", statics.meta_page_valid);
//	printf("Meta val 4 page		: %d\n\n", statics.meta_page_valid_4);
//
//	printf("Meta 0 block erase		: %d\n", statics.meta_ftl_0_block_erase);
//	printf("Meta 1 block erase		: %d\n", statics.meta_ftl_1_block_erase);
//	printf("Meta gxt block erase	: %d\n", statics.meta_ftl_context_erase_8);
//	printf("Meta pbt block erase	: %d\n", statics.meta_block_info_erase_8);
//	printf("Meta pmt block erase	: %d\n", statics.meta_page_map_erase_8);

}

void executeSequentialFullWrite(int myseq)
{
	int temp, temp2;
	//int set_sctcnt[TYPE_PAGE_SEQ] = { 8, 4, 8, 16, 32 };
	int set_sctcnt[TYPE_PAGE_SEQ] = { 8, 16, 32 ,64, 128 };

	printf("\n\n %d \n\n",myseq);

	printf("Sequential write ---------------------------------------------------\n");

	// only full sequential patern
	temp = 0;
	do
	{
		ftl_init();

		viewstatics();

		{
			extern STATISTICS statics;
			memset(&statics, 0, sizeof(statics));
		}

		unsigned int sctcnt = set_sctcnt[temp];

		printf("-------------------------------------------------------\n");
		printf("%d sector count, Sequential Write\n", sctcnt);
		printf("-------------------------------------------------------\n");

		temp2 = 0;
		do
		{
			ftl_write(temp2, sctcnt);

			temp2 += sctcnt;
		} while (temp2 < (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

		viewstatics();

		ftl_close();

		temp++;
	} while (temp < TYPE_PAGE_SEQ);

	printf("End of the sequential write -------------------------------------------\n");

}


void executeSequentialPartWrite(int myseq)
{
	int temp;
	unsigned int temp2;
	unsigned int set_amount[TYPE_PAGE_SEQ_AMOUNT] = { 2097152, (2097152 * 2), (2097152 * 3), (2097152 * 4) };
	//unsigned int set_amount[TYPE_PAGE_SEQ_AMOUNT] = { 47104, (2097152 * 2), (2097152 * 3), (2097152 * 4) };
	//unsigned int set_amount[TYPE_PAGE_SEQ_AMOUNT] = { 43680*2+1, (2097152 * 2), (2097152 * 3), (2097152 * 4) };

	int sctcnt = SECTORS_PER_PAGE;

	//printf("\n\n %d \n\n",myseq);

	printf("Sequential part write ---------------------------------------------------\n");

	// only full sequential patern
	temp = 0;
	do
	{
		ftl_init();

		viewstatics();

		{
			extern STATISTICS statics;
			memset(&statics, 0, sizeof(statics));
		}

		unsigned int writeamount = set_amount[temp];

		printf("-------------------------------------------------------\n");
		printf("%d GB write amount, Sequential Write\n", (writeamount / 1024 * 512 / 1024 / 1024));
		printf("-------------------------------------------------------\n");

		temp2 = 0;
		do
		{
			ftl_write(temp2, sctcnt);

			temp2 += sctcnt;

			if (temp2 > writeamount)
			{
				break;
			}
		} while (temp2 < (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

		viewstatics();

		ftl_close();

		temp++;

		//break;

	} while (temp < TYPE_PAGE_SEQ_AMOUNT);

	printf("end of the sequential part write ---------------------------------------------\n");

}

void makeFullCondition()
{
	ftl_init();

	ftl_write(0, (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

	viewstatics();

	ftl_close();

	getchar();
}

void _get_sct_addrs_by_group(unsigned int *sctaddrs, unsigned int group_cnt)
{
	unsigned int addr_index;
	unsigned int temp;

	if (group_cnt == 0 || group_cnt >= PMT_MAX_VALID_PAGE_COUNT)
	{
		DBG_ASSERT(0);
	}

	addr_index = 0;
	do
	{
		for (temp = 0; temp < group_cnt; temp++)
		{
			sctaddrs[addr_index] = ((temp*LP_COUNT_PER_PMT_GROUP) +
				((unsigned int)(rand() * rand()) % LP_COUNT_PER_PMT_GROUP));

			sctaddrs[addr_index] <<= 4;

			addr_index++;

			if (addr_index == COUNT_OF_PATTERN)
			{
				break;
			}
		}

	} while (addr_index < COUNT_OF_PATTERN);

}

unsigned int g_last_pg_addr =
		(((DATA_BLOCK_COUNT * PB_SECTOR_COUNT) / SECTORS_PER_PAGE) - 1);

void _get_sct_addrs_by_random(unsigned int *sctaddrs)
{
	unsigned int addr_index;

	addr_index = 0;
	do
	{
		sctaddrs[addr_index] = g_last_pg_addr--;

		addr_index++;

	} while (addr_index < COUNT_OF_PATTERN);

}

void _get_sct_addrs_128(unsigned int *sctaddrs, unsigned int max_range_rate)
{
	unsigned int max_page_cnt = ((DATA_BLOCK_COUNT * PB_SECTOR_COUNT) / SECTORS_PER_PAGE);
	unsigned int max_range;
	unsigned int temp;
	unsigned int addr_index;
	unsigned int one_pro_page_cnt = (max_page_cnt / 100);

	if (max_range_rate > 50)
	{
		DBG_ASSERT(0);
	}

	max_range = (one_pro_page_cnt * max_range_rate);
	addr_index = 0;

	temp = 0;
	do
	{

		sctaddrs[addr_index] = ((unsigned int)(rand() * rand()) % max_range);

		sctaddrs[addr_index] <<= 4;

		addr_index++;
		temp++;
	} while (temp < (COUNT_OF_PATTERN_AND - max_range_rate));


	temp = 0;
	do
	{
		sctaddrs[addr_index] = (max_range +
			((unsigned int)(rand() * rand()) % (max_page_cnt - max_range)));

		sctaddrs[addr_index] <<= 4;

		addr_index++;
		temp++;
	} while (temp < max_range_rate);

	if (addr_index != COUNT_OF_PATTERN_AND)
	{
		DBG_ASSERT(0);
	}

	temp = 0;
	do
	{
		if (sctaddrs[temp] >= (max_page_cnt << 4))
		{
			DBG_ASSERT(0);
		}

		temp++;
	} while (temp < COUNT_OF_PATTERN_AND);

}

#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_SPFTL_2KB)
unsigned int pmt_group_check[3076];
#else
unsigned int pmt_group_check[1537];
#endif
#else
unsigned int pmt_group_check[769];
#endif

void _get_sct_addrs_100(unsigned int *sctaddrs, unsigned int max_range_rate)
{
	unsigned int max_page_cnt = ((DATA_BLOCK_COUNT * PB_SECTOR_COUNT) / SECTORS_PER_PAGE);
	unsigned int max_range;
	unsigned int temp;
	unsigned int addr_index;
	unsigned int one_pro_page_cnt = (max_page_cnt / 100);

	if (max_range_rate > 50)
	{
		DBG_ASSERT(0);
	}
		
	max_range = (one_pro_page_cnt * max_range_rate);
	addr_index = 0;

	temp = 0;
	do
	{

		sctaddrs[addr_index] = ((unsigned int)(rand() * rand()) % max_range);

		/////
		{
#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_SPFTL_2KB)
			int c_pg_grp = sctaddrs[addr_index] / LP_COUNT_PER_PMT_GROUP;
#else
			int c_pg_grp = sctaddrs[addr_index] / 1365;
#endif
#else
			int c_pg_grp = sctaddrs[addr_index] / 2730;
#endif

#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_TYPE & FTL_SPFTL_2KB)
			if (c_pg_grp >=3076)
#else
			if (c_pg_grp >= 1537)
#endif
#else
			if (c_pg_grp >= 769)
#endif
			{
				DBG_ASSERT(0);
			}
			pmt_group_check[c_pg_grp]++;
		}
		/////

		sctaddrs[addr_index] <<= 4;

		addr_index++;
		temp++;
	} while (temp < (COUNT_OF_PATTERN - max_range_rate));


	temp = 0;
	do
	{
		sctaddrs[addr_index] = (max_range +
			((unsigned int)(rand() * rand()) % (max_page_cnt - max_range)));

		/////
		{
#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_TYPE & FTL_SPFTL_2KB)
			int c_pg_grp = sctaddrs[addr_index] / LP_COUNT_PER_PMT_GROUP;
#else
			int c_pg_grp = sctaddrs[addr_index] / 1365;
#endif
#else
			int c_pg_grp = sctaddrs[addr_index] / 2730;
#endif

#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_TYPE & FTL_SPFTL_2KB)
			if (c_pg_grp >= 3076)
#else
			if (c_pg_grp >= 1537)
#endif
#else
			if (c_pg_grp >= 769)
#endif
			{
				DBG_ASSERT(0);
			}
			pmt_group_check[c_pg_grp]++;
		}
		/////

		sctaddrs[addr_index] <<= 4;

		addr_index++;
		temp++;
	} while (temp < max_range_rate);

	if (addr_index != COUNT_OF_PATTERN)
	{
		DBG_ASSERT(0);
	}

	temp = 0;
	do
	{
		if (sctaddrs[temp] >= (max_page_cnt << 4))
		{
			DBG_ASSERT(0);
		}

		temp++;
	} while (temp < COUNT_OF_PATTERN);

}

unsigned int group_write_count[16]; // Group별 Write되는 회수를 구하기 위해서

void executeSyntheticRandom(int isfull,int chk_grp,int myseq)
{
	int temp_locality;
	int temp, temp2;
	int maxloop = 0;
	unsigned int sctaddrparts[COUNT_OF_PATTERN];
	//unsigned int set_locality[TYPE_OF_SYNTHETIC] = { 10, 20, 30, 40, 50 };
	unsigned int set_locality[TYPE_OF_SYNTHETIC] = { 20, 20, 30, 40, 50 };
	unsigned int set_groups[NUM_OF_CHK_GRP_PRT] =
		{ (PMT_MAX_VALID_PAGE_COUNT/10), (PMT_MAX_VALID_PAGE_COUNT/10)*20, (PMT_MAX_VALID_PAGE_COUNT-2) };

	printf("\n\n %d \n\n",myseq);

	if (isfull)
	{
		printf("Full state -----------------------------------------------\n");
	}
	else
	{
		printf("Clean state -----------------------------------------------\n");
	}

	if (chk_grp)
	{
		maxloop = NUM_OF_CHK_GRP_PRT;
	}
	else
	{
		maxloop = TYPE_OF_SYNTHETIC;
	}

	temp_locality = 0;
	do
	{
		ftl_init();

		viewstatics();

		if (isfull)
		{
			extern STATISTICS statics;

			ftl_write(0, (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

			memset(&statics, 0, sizeof(statics));
		}

		if (chk_grp)
		{
			printf("%d groups in %d ----------------------------------------\n",
				set_groups[temp_locality],
				PMT_MAX_VALID_PAGE_COUNT);
		}
		else
		{
			printf("%d:%d rate -----------------------------------------------\n",
				set_locality[temp_locality],
				(PERCENT_100 - set_locality[temp_locality]));
		}



		temp = 0;
		do
		{
			unsigned int sctcnt = SECTORS_PER_PAGE;

			if (chk_grp)
			{
				_get_sct_addrs_by_group(sctaddrparts,set_groups[temp_locality]);
			}
			else
			{
				_get_sct_addrs_100(sctaddrparts, set_locality[temp_locality]);
			}

			temp2 = 0;
			do
			{
				ftl_write(sctaddrparts[temp2], sctcnt);


				/////////////// Group 별 Write 회수 구하기
				{
					unsigned int grp_idx_write = (sctaddrparts[temp2] / (2097152)); // 1GB로 나누면 group index가 됨
					if (grp_idx_write > 15)
					{
						DBG_ASSERT(0);
					}
					group_write_count[grp_idx_write]++;
				}
				/////////////// Group 별 Write 회수 구하기

				temp2++;
			} while (temp2 < COUNT_OF_PATTERN);
			//} while (temp2 < 80);

			//for (int igrp = 0; igrp < 16; igrp++)
			//{
			//	printf("grp[%d]:%d\n", igrp, group_write_count[igrp]);
			//}

			temp += (COUNT_OF_PATTERN*sctcnt);
		} while (temp < (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

		viewstatics();

		for (int igrp = 0; igrp < 16; igrp++)
		{
			printf("grp[%d]:%d\n", igrp, group_write_count[igrp]);
			group_write_count[igrp] = 0;
		}

#if ((FTL_TYPE & FTL_SPFTL) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#if (FTL_TYPE & FTL_SPFTL_2KB)
		for (int ipmt = 0; ipmt < 3076; ipmt++)
#else
		for (int ipmt = 0; ipmt < 1365; ipmt++)
#endif
#else
		for (int ipmt = 0; ipmt < 769; ipmt++)
#endif
		
		{
			printf("pgrp[%d]=%d\n", ipmt, pmt_group_check[ipmt]);
		}

		ftl_close();

		temp_locality++;

		break;

	} while (temp_locality < maxloop);

	if (isfull)
	{
		printf("End of the full state -----------------------------------------------\n");
	}
	else
	{
		printf("End of the clean state -----------------------------------------------\n");
	}
}

#define NUM_OF_NEXUS5_TYPE		(31)

// C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\

void executeNexus5Pattern(int isfull, int isdirty, int myseq)
{
	FILE *fp = NULL;
	unsigned int temp;
	unsigned int nPatternSctCnt = 0;
	unsigned int nPatternSctAddr = 0;
	unsigned int nPatternByte = 0; 
	unsigned int nType = 0;
	float nGenTime, nStartTime, nTime2HW, nFinTime;
	unsigned int nLineCnt = 0;

	char fname[NUM_OF_NEXUS5_TYPE][FNAME_MAX_LENGTH] =
	{
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log106_Messaging.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log111_email.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log121_Movie.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log125_copyHtoD.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log126_copyDtoH.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log131_music.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log132_radio.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log136_idle.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log146_callIn.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log147_callout.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log152_YouTube.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log156_download.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log161_cameraVideo.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log166_webBrowsing.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log171_angrybird.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log176_Booting.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log181_Installing.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log186_twitter.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log191_facebook.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log196_Amazon.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log201_GoogleMap.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log202_GoogleMap.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log220_MusicWebBrowse.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log225_MusicFaceBook.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log225_MusicTwitter.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log230_MusicMessage.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log235_RadioFaceBook.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log240_RadioMessage.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log245_MusicFaceBook.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log250_RadioWebBrowse.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Nexus5\\log260_FaceBookHandOuts.txt"
	};

	printf("\n\n %d \n\n", myseq);

	if (isfull)
	{
		printf("Full&Dirty Nexus5 ---------------------------------------------------\n");
	}
	else
	{
		printf("Clean Nexus5 ---------------------------------------------------\n");
	}

	ftl_init();

	viewstatics();

	if (isfull)
	{
		extern STATISTICS statics;

		ftl_write(0, (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

		memset(&statics, 0, sizeof(statics));

		///////////////
		if (isdirty)
		{
			unsigned int sctaddrparts[COUNT_OF_PATTERN_AND];
			unsigned int temp_dirty = 0;
			unsigned int temp_dirty2 = 0;

			do
			{
				unsigned int sctcnt = SECTORS_PER_PAGE;

				_get_sct_addrs_128(sctaddrparts, 50);

				temp_dirty2 = 0;
				do
				{
					ftl_write(sctaddrparts[temp_dirty2], sctcnt);

					temp_dirty2++;
				} while (temp_dirty2 < COUNT_OF_PATTERN_AND);

				temp_dirty += (COUNT_OF_PATTERN_AND*sctcnt);
			} while (temp_dirty < (((OP_USR_FB_COUNT * 6) / 10) * PB_SECTOR_COUNT));

			memset(&statics, 0, sizeof(statics));
		}
		///////////////

	}

	temp = 0;
	do
	{
		fp = fopen(fname[temp], "r");

		if (fp == NULL)
		{
			printf("File does not exist\n");
			DBG_ASSERT(0);
		}

		while (1)
		{
			if (fscanf(fp, "%d %d %d %d %f %f %f %f\n", &nPatternSctAddr, &nPatternSctCnt, &nPatternByte, &nType, 
				&nGenTime, &nStartTime, &nTime2HW, &nFinTime) == EOF)
			{
				fclose(fp);
				fp = NULL;
				break;
			}
			
			nLineCnt++;

			// column 3. access type & waiting or not: the lowest bit to indicate read or write (0 is read and 1 is write), 
			// the third bit represent the request have be waiting or not (4 indicate no wait while 0 indicate has been waiting some time)
			// For instance 5 represents that the request is a write request and the request does not wait before been processed, 
			// which indicates the queue is empty when the request comes.

			if (nType & 0x1)
			{
				ftl_write(nPatternSctAddr, nPatternSctCnt);
			}
		}

		if (fp != NULL)
		{
			fclose(fp);
			fp = NULL;
		}

		temp++;
	} while (temp < NUM_OF_NEXUS5_TYPE);

	viewstatics();

	ftl_close();

	if (isfull)
	{
		printf("End of the full Nexus5 ---------------------------------------------------\n");
	}
	else
	{
		printf("End of clean Nexus5 ---------------------------------------------------\n");
	}


}

void executeAndroidPattern(int isfull, int isdirty, int myseq)
{
	FILE *fp = NULL;
#if (CHECK_LATENCY == 1)
	FILE *fp2 = NULL;
	
#if (FTL_TYPE == (FTL_BASELINE | FTL_16GB))
	char fname2[TYPE_OF_ANDRIOD][FNAME_MAX_LENGTH] =
	{
		"./latency_heavy_base.txt",
		"./latency_normal_base.txt",
		"./latency_normal2_base.txt"
	};
#elif (FTL_TYPE == (FTL_SPFTL_MIXED | FTL_16GB))
	char fname2[TYPE_OF_ANDRIOD][FNAME_MAX_LENGTH] =
	{
		"./latency_heavy_spftl_mixed.txt",
		"./latency_normal_spftl_mixed.txt",
		"./latency_normal2_spftl_mixed.txt"
	};
#else
	char fname2[TYPE_OF_ANDRIOD][FNAME_MAX_LENGTH] =
	{
		"./latency_heavy_spftl.txt",
		"./latency_normal_spftl.txt",
		"./latency_normal2_spftl.txt"
	};
#endif

#endif
	unsigned int temp;
	unsigned int nPatternSctCnt = 0;
	unsigned int nPatternSctAddr = 0;
	unsigned int nLineCnt = 0;
	char fname[TYPE_OF_ANDRIOD][FNAME_MAX_LENGTH] =
	{
		
		"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_gb_heavy_20130102.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_normal_gb_20130103.txt",
		"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_normal_gb2_20130103.txt",
		//"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_gb_heavy_20130102.txt",
		//"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_normal_gb_20130103.txt",
		//"C:\\paper_spftl\\workspace\\SPFTL\\Android\\4gb_normal_gb2_20130103.txt"
	};

	printf("\n\n %d \n\n",myseq);

	if (isfull)
	{
		printf("Full&Dirty Andriod ---------------------------------------------------\n");
	}
	else
	{
		printf("Clean Andriod ---------------------------------------------------\n");
	}

	temp = 0;
	do
	{
		ftl_init();

		viewstatics();

		if (isfull)
		{
			extern STATISTICS statics;

			ftl_write(0, (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

			memset(&statics, 0, sizeof(statics));
		} 
		
		if (isdirty)
		{
			unsigned int sctaddrparts[COUNT_OF_PATTERN_AND];
			unsigned int temp_dirty = 0;
			unsigned int temp_dirty2 = 0;
			unsigned int temp_dirty_fill = 0;

			do
			{
				unsigned int sctcnt = SECTORS_PER_PAGE;

				if (isfull)
				{
					if (temp_dirty_fill >= 5)
					{
						temp_dirty_fill = 0;
					}

					temp_dirty_fill++;

					_get_sct_addrs_128(sctaddrparts, temp_dirty_fill*10);
				}
				else
				{
					_get_sct_addrs_128(sctaddrparts, 50);
				}

				temp_dirty2 = 0;
				do
				{
					//if (temp_dirty == 12288)
					//{
					//	DBG_ASSERT(0);
					//}

					ftl_write(sctaddrparts[temp_dirty2], sctcnt);

					temp_dirty2++;
				} while (temp_dirty2 < COUNT_OF_PATTERN_AND);

				temp_dirty += (COUNT_OF_PATTERN_AND*sctcnt);
			//} while (temp_dirty < (((OP_USR_FB_COUNT*6)/10) * PB_SECTOR_COUNT));
			} while (temp_dirty < (DATA_BLOCK_COUNT * PB_SECTOR_COUNT));

			{
				extern STATISTICS statics;

				memset(&statics, 0, sizeof(statics));
			}
		}

		fp = fopen(fname[temp], "r");

		if (fp == NULL)
		{
			printf("File does not exist\n");
			DBG_ASSERT(0);
		}

#if (CHECK_LATENCY == 1)
		fp2 = fopen(fname2[temp], "w");
		
		if (fp2 == NULL)
		{
			printf("File does not exist\n");
			DBG_ASSERT(0);
		}
#endif
		{
			extern STATISTICS statics;

			statics.aged = 1;
		}

		while (1)
		{
			if (fscanf(fp, "%d %d\n", &nPatternSctAddr, &nPatternSctCnt) == EOF)
			{
				fclose(fp);
				break;
			}

			nLineCnt++;
#if (CHECK_LATENCY == 1)
			{
				extern STATISTICS statics;

				statics.nand_tR = 0;
				statics.nand_tProg = 0;
				statics.nand_tErase = 0;
				statics.nand_tDMA = 0;
			}
#endif

#if (CHECK_PER_REQ == 1)
			{
				extern STATISTICS statics;

				memset(&statics, 0, sizeof(statics));
			}
#endif

			//if (nLineCnt == 28089)
			//{
			//	DBG_ASSERT(0);
			//}

			ftl_write(nPatternSctAddr, nPatternSctCnt);

#if (CHECK_PER_REQ == 1)
			{
				viewstatic_per_req();
			}
#endif

#if (CHECK_LATENCY == 1)
			{
				extern STATISTICS statics;

				//unsigned long total_us = ((statics.nand_tR * 80) + (statics.nand_tProg * 1600) +
				//	(statics.nand_tErase * 1500) + ((statics.nand_tDMA * 1024 * 1000 * 1000) / 41943040));


				//if (total_us == 0)
				//{
				//	DBG_ASSERT(0);
				//}

				//fprintf(fp2, "%u\n", total_us);

				fprintf(fp2, "%d %d %d %d\n", statics.nand_tR, statics.nand_tProg, statics.nand_tErase, statics.nand_tDMA);
			}
			
#endif
		}

		fclose(fp);

#if (CHECK_LATENCY == 1)
		fclose(fp2);
#endif

		viewstatics();

		printf("-------------------------------------------------------\n");

		ftl_close();

		temp++;

		//break;

	} while (temp < TYPE_OF_ANDRIOD);

	if (isfull)
	{

		printf("End of the full Andriod ---------------------------------------------------\n");
	}
	else
	{
		printf("End of clean Andriod ---------------------------------------------------\n");
	}

}

int main(int argc, char **argv)
{
	srand(100);

	printf("유의사항: RAMNAND.h의 NAND 크기와 SPFTL.h에서의 FTL 종류를 동일하게 맞춰야 한다.\n");

#if (FTL_TYPE == (FTL_BASELINE | FTL_16GB))
	printf("--- Baseline FTL Context Size(Byte) ---\n");

	printf("16GB: %ld\n",sizeof(CONTEXT));

	printf("32GB: %ld\n",sizeof(CONTEXT_32GB));

	printf("64GB: %ld\n",sizeof(CONTEXT_64GB));

	//printf("SPFTL MIXED 16GB: %ld\n", sizeof(CONTEXT_SPFTL_MIXED));

	printf("--- SPFTL 4KB Half Context Size(Byte) ---\n");

	printf("16GB: %ld\n",sizeof(CONTEXT_SPFTL));

	printf("32GB: %ld\n",sizeof(CONTEXT_SPFTL_32GB));

	printf("64GB: %ld\n",sizeof(CONTEXT_SPFTL_64GB));

	printf("--- Other Buffers ---\n");

	printf("CACHEPMT: %d\n", sizeof(CACHEPMT));
	printf("CACHEPMTDIRTY: %d\n", sizeof(CACHEPMTDIRTY));
	printf("CACHEPBT: %d\n", sizeof(CACHEPBT));
	printf("CACHEPBTDIRTY: %d\n", sizeof(CACHEPBTDIRTY));
	printf("GXTPOINTER: %d\n", sizeof(GXTPOINTER));
	printf("GXTPTRBLKINFO: %d\n", sizeof(GXTPTRBLKINFO));
	
	printf("temp buffer + copy back buffer: 16384\n");
	// unsigned char nand_copyback_buffer[8192];
	// unsigned char temp_buffer[8192];
#endif

	printf("--- FTL Context Size(Byte) ---\n");

	printf("Context Size: %ld\n",sizeof(CONTEXT));
	printf("Global log size: %ld\n", sizeof(DIFFGLOBALCXT));

	//executeSequentialFullWrite(1);
	//executeSequentialPartWrite(2);
	
	//executeSyntheticRandom(NO_FILL_PATTERN,CHK_RANDOM_BY_LOCALITY,3);
	//executeSyntheticRandom(NO_FILL_PATTERN, CHK_RANDOM_BY_PMGRP, 3);
	//executeSyntheticRandom(FILL_PATTERN,CHK_RANDOM_BY_LOCALITY,3);

	//executeAndroidPattern(NO_FILL_PATTERN,CHK_IS_NOT_DIRTY,4);
	//executeAndroidPattern(FILL_PATTERN,CHK_IS_NOT_DIRTY,4);
	//executeAndroidPattern(NO_FILL_PATTERN, CHK_IS_DIRTY, 4);
	executeAndroidPattern(FILL_PATTERN, CHK_IS_DIRTY, 5);

	//executeNexus5Pattern(NO_FILL_PATTERN, CHK_IS_NOT_DIRTY, 5);
	//executeNexus5Pattern(FILL_PATTERN, CHK_IS_NOT_DIRTY, 5);
	//executeNexus5Pattern(FILL_PATTERN, CHK_IS_DIRTY, 5);
	//getchar();
	//{
	//	extern int flush_num;
	//	printf("%d\n",flush_num);
	//}

	return 0;
}
