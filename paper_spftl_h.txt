/*
 * SPFTL.h
 *
 *  Created on: 2016. 11. 30.
 *      Author: 김정훈
 */

#ifndef INC_SPFTL_H_
#define INC_SPFTL_H_

// sanghoon@calab.kaist.ac.kr
// jinsookim@skku.edu

#define L2P_MAP_CACHE_MAX_COUNT		(128)
#define PB_CAHCE_MAX_COUNT			(128)

#define PMT_STORE_DISTANCE			(0)

#pragma pack(push,1)
// LOG 8 Bytes
typedef struct
{
	unsigned char vpcnt;	// MLC 128 page까지 가능하므로, 1 byte를 이용
	unsigned char fpofset;	// MLC 128 page까지 사용하므로, 1 byte를 이용
	unsigned short pbaddr;	// 2 byte, 전체 block이 16386개가 표현되므로, short 사용
	unsigned int erscnt;    // erase count를 별도로 관리함, user block cache와 분리, gc시에 load/store 되는 overhead 제거,
} LOG;
// LOG의 종류는 3가지
// UpdateBlock : User data를 쓰는 블럭
// GCBlock : User data 블럭이 꽉 찼을 때 GC를 수행하기 위해 지우고 카피하는 블럭
// MetaGCBlock : Meta data 블럭이 꽉찼을 때 GC를 수행하기 위해 지우고 카피하는 블럭
//				GXT, PBT, PMT meta block과 교환되는 블럭


// LOG 7 Bytes
typedef struct
{
	unsigned char vpcnt;	// MLC 128 page까지 가능하므로, 1 byte를 이용
	unsigned char fpofset;	// MLC 128 page까지 사용하므로, 1 byte를 이용
	unsigned char pbaddr;	// 1 byte, Meta 범위는 한정되므로 1 byte로 표현가능
	unsigned int erscnt;    // erase count를 별도로 관리함, user block cache와 분리, gc시에 load/store 되는 overhead 제거,
} METALOG;
#pragma pack(pop)

#pragma pack(push,1)
// GC를 위한 블럭
// 6 Bytes
typedef struct
{
	unsigned int erscnt;
	unsigned short pbaddr;
} GCBLK;

// Meta GC를 위한 블럭
// 5 Bytes
typedef struct
{
	unsigned int erscnt;
	unsigned char pbaddr;
} METAGCBLK;
#pragma pack(pop)

// GXT가 모두 쓰여져 찾을 경우, MetaGCBlock과 교환되면 전체 메타 블럭에 CXT가 존재하게 된다.
// 초기 Power On에는 CXT가 필요한데, CXT를 찾기 위해 운이 없으면 모든 메타 블럭을 찾게 된다.
// 이를 막기 위해, GXT Pointer Structure 사용한다.
// 0, 1번 블럭을 사용하고, GXT 블럭의 물리적 위치가 변경될 때에 이곳에 해당 GXT 블럭 위치를 기록한다.
// CXT 블럭의 모든 페이지가 쓰여지고 지울때만 변경되므로, 64 Page(SLC Mode) 저장에 한번 기록된다.
// 0번과 1번의 최근 블럭의 구분은  --Age를 반영하여 저장하고 이를 비교하여 두 블럭 중에 최근 블럭을 구분하도록 한다.
// 10Bytes
typedef struct
{
	unsigned char gxtpbaddr;
	unsigned int erscnt[2];			// 0번과 1번 블럭의 erase count
	unsigned int age;				// 0번과 1번에 적힌 페이지의 최신 순위를 나태내기 위함
} GXTPOINTER;

// Cache for GXTPOINTER write
typedef struct
{
	unsigned char pbaddr;
	unsigned char fpofset;
} GXTPTRBLKINFO;

#pragma pack(push,1)
// PB 5Byte
typedef struct
{
	unsigned int erscnt;		// 100K slc endurance까지 표현하기 위해  4 byte 사용
	unsigned char vpcnt;	// 128 page까지 가능하므로, 1 byte를 이용
} PB;
#pragma pack(pop)

#define FTL_BASELINE			(0x01)
#define FTL_SPFTL				(0x02)
#define FTL_SPFTL_MIXED			(0x04)			// SPFTLlog 같음
#define FTL_SPFTL_LOGGING		(0x08)

#define FTL_16GB				(0x10)
#define FTL_32GB				(0x20)

#define FTL_SPFTL_2KB			(0x40)
#define FTL_BASELINE_EXT		(0x80)

//#define FTL_TYPE	(FTL_BASELINE | FTL_16GB)		// FTL Type 지정

//#define FTL_TYPE	(FTL_BASELINE | FTL_16GB)		// FTL Type 지정

//#define FTL_TYPE	(FTL_BASELINE | FTL_BASELINE_EXT | FTL_16GB)		// FTL Type 지정

#define FTL_TYPE	(FTL_SPFTL_MIXED | FTL_16GB)		// FTL Type 지정

//#define FTL_TYPE	(FTL_SPFTL_LOGGING | FTL_16GB)		// FTL Type 지정

//#define FTL_TYPE	(FTL_SPFTL | FTL_16GB)		// FTL Type 지정

//#define FTL_TYPE	(FTL_SPFTL | FTL_SPFTL_2KB | FTL_16GB)		// FTL Type 지정

// Baseline FTL
// PB 하나가 5Byte 이므로 8KB인 한 페이지에 8192/5 = 1638 개만  들어감
// 16GB일 경우, 1MB가 1블럭을 가정 했으므로, (128 page * 8KB = 1MB),
// 16384개의 블럭을 1638개로 나누면 전체 11개의 그룹이 생겨남(NG = 11)
// 16GB일 경우 11개, 32GB일 경우 21개, 64GB일 경우 41개

#define PBT_MAX_VALID_PAGE_COUNT_16GB	(11)	// 16GB
#define PBT_MAX_VALID_PAGE_COUNT_32GB	(21)	// 32GB
#define PBT_MAX_VALID_PAGE_COUNT_64GB	(41)	// 64GB

// SPFTL 4KB Half page
// 4KB 한 페이지에 4096/5 = 819 개만 들어감
// 16GB 16384 블럭을 819로 나누면 전체 21개의 그룹이 생겨남 (NG = 21)
// 32GB일 경우 41개, 64GB일 경우  81개
#define PBT_MAX_VALID_PAGE_COUNT_SPFTL		(21)
#define PBT_MAX_VALID_PAGE_COUNT_SPFTL_16GB	(21)	// 16GB 일 경우
#define PBT_MAX_VALID_PAGE_COUNT_SPFTL_32GB	(41)	// 32GB
#define PBT_MAX_VALID_PAGE_COUNT_SPFTL_64GB	(81)	// 64GB

// Baseline FTL
 // 16GB, 8KB(낸드 페이지) 단위로 맵핑하면,
 // 16GB/8KB = 2097152개로 표현됨
 // 32GB는 4194304개
 // 64GB는 8388608개
 // FTL에서 사용할 Page map은 메모리에서 3바이트로 표현이 가능함(2바이트 Block, 1바이트 Page)
 // 메모리에서 3바이트로 표현되므로, GTD 엔트리 하나는 8KB 낸드 페이즈 만큼 저장할 수 있으므로,
 // 8KB/3B = 2730개의 Page maps를 가질 수 있다.
//#define LP_COUNT_PER_PMT_GROUP		(2730)
 // 따라서,
 // 16GB인 경우, 2097152 / 2730 = 769 GTD entries
 // 32GB인 경우, 1537 GTD entries
 // 64GB인 경우, 3073 GTD entries

 // CXT Size 16GB
 // LOG 3개 : 3 * 4Byte = 12
 // VICTIMINFO 1개: 1 * 33Byte = 33
 // PBT: 22
 // PMT: 769 * 2 = 1538
 // 즉, Total CXT 크기는 1605 Bytes

 // CXT Size 32GB
 // PMT: 1537 * 2 =  3074
 // VICTIM: 63
 // LOG : 12
 // PBT : 42
 // TOTAL : 3191

 // CXT Size 64GB
 // PMT: 3073 * 2 = 6146
 // VICTIM: 123
 // LOG: 12
 // PBT: 82
 // TOTAL: 6363

#define PMT_MAX_VALID_PAGE_COUNT_16GB  		(769)
#define PMT_MAX_VALID_PAGE_COUNT_32GB   	(1537)
#define PMT_MAX_VALID_PAGE_COUNT_64GB   	(3073)

 // SPFTL 4KB Half page
 // 4KB/3B = 1365 page maps per GTD
 // 16GB인 경우, 2097152 / 1365 = 1537 GTD Entries
 // 32GB인 경우, 3073
 // 64GB, 6146

#define PMT_MAX_VALID_PAGE_COUNT_SPFTL			(1537)
#define PMT_MAX_VALID_PAGE_COUNT_SPFTL_16GB		(1537)
#define PMT_MAX_VALID_PAGE_COUNT_SPFTL_32GB   	(3073)
#define PMT_MAX_VALID_PAGE_COUNT_SPFTL_64GB   	(6146)

/// FTL Type에 따른 상수 정의

#if (FTL_TYPE & FTL_BASELINE) 

#if (FTL_TYPE & FTL_BASELINE_EXT)

#define PB_COUNT_PER_VALID_PAGE			(1638)	// Density에 따라 개수 차이 없음(8192/5)
#define LP_COUNT_PER_PMT_GROUP			(1365)		// 4KB/3B

#define PBT_MAX_VALID_PAGE_COUNT     	(PBT_MAX_VALID_PAGE_COUNT_16GB)
#define PMT_MAX_VALID_PAGE_COUNT		(2097152/LP_COUNT_PER_PMT_GROUP)

#else
#define PB_COUNT_PER_VALID_PAGE			(1638)	// Density에 따라 개수 차이 없음(8192/5)
#define LP_COUNT_PER_PMT_GROUP			(2730)		// 8KB/3B

#if (FTL_TYPE & FTL_16GB)
#define PBT_MAX_VALID_PAGE_COUNT     	(PBT_MAX_VALID_PAGE_COUNT_16GB)
#define PMT_MAX_VALID_PAGE_COUNT		(PMT_MAX_VALID_PAGE_COUNT_16GB)
#elif  (FTL_TYPE & FTL_32GB)
#define PBT_MAX_VALID_PAGE_COUNT     	(PBT_MAX_VALID_PAGE_COUNT_32GB)
#define PMT_MAX_VALID_PAGE_COUNT		(PMT_MAX_VALID_PAGE_COUNT_32GB)
#endif

#endif

#elif (FTL_TYPE == (FTL_SPFTL | FTL_16GB))
#define PBT_MAX_VALID_PAGE_COUNT		(PBT_MAX_VALID_PAGE_COUNT_SPFTL_16GB)
#define PMT_MAX_VALID_PAGE_COUNT		(PMT_MAX_VALID_PAGE_COUNT_SPFTL_16GB)

#define PB_COUNT_PER_VALID_PAGE			(819)	// Density에 따라 개수 차이 없음(4096/5)
#define LP_COUNT_PER_PMT_GROUP			(1365)		// 4KB/3B
#elif (FTL_TYPE == (FTL_SPFTL_LOGGING | FTL_16GB))
#define PBT_MAX_VALID_PAGE_COUNT		(PBT_MAX_VALID_PAGE_COUNT_SPFTL_16GB)
#define PMT_MAX_VALID_PAGE_COUNT		(PMT_MAX_VALID_PAGE_COUNT_SPFTL_16GB)

#define PB_COUNT_PER_VALID_PAGE			(819)	// Density에 따라 개수 차이 없음(4096/5)
#define LP_COUNT_PER_PMT_GROUP			(1365)		// 4KB/3B
#elif (FTL_TYPE == (FTL_SPFTL_MIXED | FTL_16GB))
//#define PB_COUNT_PER_VALID_PAGE			(1638)	// Density에 따라 개수 차이 없음(8192/5)
#define PB_COUNT_PER_VALID_PAGE			(819)	// Density에 따라 개수 차이 없음(4096/5)
#define LP_COUNT_PER_PMT_GROUP			(2730)		// 8KB/3B

//#define PBT_MAX_VALID_PAGE_COUNT     	(PBT_MAX_VALID_PAGE_COUNT_16GB)
#define PBT_MAX_VALID_PAGE_COUNT     	(PBT_MAX_VALID_PAGE_COUNT_SPFTL)
#define PMT_MAX_VALID_PAGE_COUNT		(PMT_MAX_VALID_PAGE_COUNT_16GB)
#elif (FTL_TYPE == (FTL_SPFTL | FTL_SPFTL_2KB | FTL_16GB))
#define PB_COUNT_PER_VALID_PAGE			(409)	// Density에 따라 개수 차이 없음(2048/5)
#define LP_COUNT_PER_PMT_GROUP			(682)		// 2KB/3B

#define PBT_MAX_VALID_PAGE_COUNT     	(41)	// 16384 / (2048/5)
#define PMT_MAX_VALID_PAGE_COUNT		(3076)  // 2097152 / (2048/3)

#endif

// PB 8Byte
// pbindexforlog, SPFTL Mixed Mode에서만 사용됨, PBT의 하나의 Valid Page 내부에서 변화된 곳의 PB의 Index,
// Logging 시에 Index를 알기 위해 사용된다. PBT Logging은 PB의 변한 것들만 모으게 되므로 Index가 필요하다.
//typedef struct
//{
// unsigned int erasecount;
// unsigned char validpagecount;
// unsigned char validbitmap;
// unsigned short pbindexforlog;
//} PB;
#pragma pack(push,1)
typedef struct
{
	unsigned short pbaddr;
	unsigned char pgofset;
} USRLPNDESC;
#pragma pack(pop)

// PBCACHEUNIT
// PB 단위로 Cache하기 위한 단위 구조체
// PBUNIT 7Byte
typedef struct
{
 unsigned short pbaddr;
 PB pbunit;
 //unsigned char align4byte[ALIGN_4BYTE_WITH_2_BYTE];
} PBUNIT;


// META PBCACHEUNIT
// PB 단위로 Cache하기 위한 단위 구조체
// PBUNIT 6Byte
typedef struct
{
 unsigned char pbaddr;
 PB pbunit;
} METAPBUNIT;

// PB들을 Cache하기 위한 배열 구조체
// updateblock에 최대 128 page(mlc)가 쓰여지므로, 최소 128개로 구성
// 또한, gc를 위한 PB를 1개 더 추가
typedef struct
{
 PBUNIT tong[PB_CAHCE_MAX_COUNT];
} CACHEPBT;

// L2P cache dirty 확인을 위한 배열 구조체
// 1 * 128 + 3 = 132Byte
typedef struct
{
 unsigned char updated[PB_CAHCE_MAX_COUNT];
 //unsigned char align4byte[ALIGN_4BYTE_WITH_3_BYTE];
} CACHEPBTDIRTY;

// L2PUNIT 8Byte
// LPN 단위로 Cache하기 위한 단위 구조체
typedef struct
{
 unsigned int lpn;
 unsigned int ppn;
} L2PUNIT;

// L2P를 Cache하기 위한 배열 구조체
// updateblock을 모두 Write할 경우, PMT Flush를 수행한다.
// 따라서, L2P_MAX_COUNT: 128 Page (MLC)
// 8 * 128 = 1024Byte
typedef struct
{
 L2PUNIT tong[L2P_MAP_CACHE_MAX_COUNT];
} CACHEPMT;

// L2P cache dirty 확인을 위한 배열 구조체
// 1 * 128 = 128Byte
typedef struct
{
 unsigned char updated[L2P_MAP_CACHE_MAX_COUNT];
} CACHEPMTDIRTY;

// PMT 블럭의 개수는 한 PBT Block가 가지는 Valid Page Count와 동일하게 하기 위함
#pragma pack(push,1)
typedef struct
{
#if (FTL_TYPE & FTL_SPFTL_2KB)
	METAPBUNIT pmtblks[256];
#else
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT/PBT_MAX_VALID_PAGE_COUNT)];
#endif
} PMTGCVICTIMS;
#pragma pack(pop)

#pragma pack(push,1)
#define PMT_BASELINE_HALF_CNT		(32)
//typedef struct
//{
//	METAPBUNIT pmtblks[PMT_BASELINE_HALF_CNT];
//	METAPBUNIT sp_pmtblks[PMT_BASELINE_HALF_CNT];
//} PMTGCVICTIMS_MIXED;
typedef struct
{
	METAPBUNIT pmtblks[16];
	METAPBUNIT sp_pmtblks[48];
} PMTGCVICTIMS_MIXED;
#pragma pack(pop)


#pragma pack(push,1)
typedef struct
{
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT_32GB/PBT_MAX_VALID_PAGE_COUNT_32GB)];
} PMTGCVICTIMS_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT_64GB/PBT_MAX_VALID_PAGE_COUNT_64GB)];
} PMTGCVICTIMS_64GB;
#pragma pack(pop)


#pragma pack(push,1)
typedef struct
{
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT_SPFTL/PBT_MAX_VALID_PAGE_COUNT_SPFTL)];
} PMTGCVICTIMS_SPFTL;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT_SPFTL_32GB/PBT_MAX_VALID_PAGE_COUNT_SPFTL_32GB)];
} PMTGCVICTIMS_SPFTL_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	METAPBUNIT pmtblks[(PMT_MAX_VALID_PAGE_COUNT_SPFTL_64GB/PBT_MAX_VALID_PAGE_COUNT_SPFTL_64GB)];
} PMTGCVICTIMS_SPFTL_64GB;
#pragma pack(pop)


// GC Victim을 선별하기 위한 구조체
// PBT의 Valid Page 1개 내부의 PB들(1024개, 8KB NAND Page, 8Byte per block) 중에,
// 가장 작은 Valid Page를 가지는 PB의 physicalblockaddr와 Valid Page Count를 저장
// 33Byte

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT];
} MINIMUMVALIDPAGECOUNTFORGC;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT_32GB];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT_32GB];
} MINIMUMVALIDPAGECOUNTFORGC_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT_64GB];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT_64GB];
} MINIMUMVALIDPAGECOUNTFORGC_64GB;
#pragma pack(pop)


// SPFTL 4KB

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT_SPFTL];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT_SPFTL];
} MINIMUMVALIDPAGECOUNTFORGC_SPFTL;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT_SPFTL_32GB];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT_SPFTL_32GB];
} MINIMUMVALIDPAGECOUNTFORGC_SPFTL_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
 unsigned short pbaddr[PBT_MAX_VALID_PAGE_COUNT_SPFTL_64GB];
 unsigned char vpcnt[PBT_MAX_VALID_PAGE_COUNT_SPFTL_64GB];
} MINIMUMVALIDPAGECOUNTFORGC_SPFTL_64GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	unsigned char page_group_count[2048];	// 1KB // how many times logs updated before merging
} PAGEMAPLOCCNT;
typedef struct
{
	unsigned char block_group_count[32];
} BLOCKGROUPLOCCNT;
#pragma pack(pop)

/*
#pragma pack(push,1)
typedef struct
{
 LOG uptgxtblk;
 LOG uptpbtblk;
 LOG uptpmtblk;
 // LOG 8Byte
 // GXT, PBT, PMT를 쓰기 위한 블럭

 LOG uptblk;
 // 호스트 데이터를 저장하기 위한 블럭
 // 모든 128 Page(MLC)가 Write되면 PMT, PBT를 저장하고, GXT를 저장한다.
 // Power Off 이후, updateblock을 Scan 하면,
 // Page mappings 정보들과 block의 valid page count들이 최신 정보로 갱신될 수 있다.
 // 이 과정을 실행하고 context가 저장될 시점에 변경될 수 있는 context 정보는 아래 4가지 필드,
 // pbtblock, pmtblock, pmtvalidpagelocation, pbtvalidpagelocation 이다.
 // LOG 8Byte

 GCBLK usrgcblk;
 // updateblock의 GC를 수행하기 위한 블록
 // GC 중에 Power off가 발생할 수 있다. GC가 실행되기 직전의 context 정보를 유지한다면 다음 GC에 문제가 없다.
 // 이를 위해, GC 시작 시에 GXT 변화가 있었다면 저장하고, GC 종료 후에 GXT를 저장하도록 한다.
 // GC 중에 Power off가 발생해도 Power Off가 발생하기 전 GXT로 Roll Back이 자동적으로 된다.
 // GC Power off 대비를 위한 추가적인 context 변수는 없어도 된다.
 // LOG 4Byte

 GCBLK metagcblk;
 // GXT, PBT, PMT의 GC가 요구될 때, 사용되는 블록
 // LOG 4Byte

 // pbtblock의 블럭 위치는 고정이므로, PBT에 바로 쓴다.
 // LOG pbtblock;
 // 16GB 기준 (8KB NAND page, 8Byte per block) 16개 valid page를 1개의 block에 저장
 // SLC block은 기준 64 page(MLC는 128 page, LSB backup 필요, 신뢰성 문제(endurance, retention)로 MLC block 배제)를 가진다.
 // 하나의 SLC block이면 모든 16개의 PBT valid page를 저장 할 수 있으므로 하나의 SLC Block으로 구성한다.
 // LOG 8 Byte

 // freeblockforpbtblockgc의 블럭 위치는 고정이므로, PBT에 바로 쓴다.
 // LOG freeblockforpbtblockgc;
 // pbtblock GC를 위한 free block
 // updatelog GC Power off 처리와 동일하게 GC 처음과 마지막에 context를 저장하도록 한다.
 // PBT는 최대 16개의 valid page가 생성되므로, GC 시에 16개의 valid page copy가 발생할 수 있다.
 // GC 시에 발생하는 valid page copy를 줄이려면 PBT Block 개수를 늘리면 된다.
 // LOG 8Byte

 // pmtblock의 블럭 위치는 고정이므로, PBT에 바로 쓴다.
 // LOG pmtblock[PMT_BLOCK_COUNT - 1];
 // updatepmtblock의 블럭 위치는 고정이므로, PBT에 바로 쓴다.
 // LOG updatepmtblock;
 // 16GB 기준 (8KB NAND Page, 4Byte per page mapping) 1024개 valid page를 64개의 Block에 저장,
 // pbtblock과 같은 기준으로 PMT block 개수를 할당했다. 1024개의 valid page가 SLC block에 고르게 분포될 경우,
 // 하나의 SLC block에는 16개의 valid page가 생성된다. 따라서, 64개의(=1024/16) PMT Block이 할당된다.
 // 8 * 64 = 512Byte

 // freeblocforupdatepmtblockgc의 블럭 위치는 고정이므로, PBT에 바로 쓴다.
 // LOG freeblocforupdatepmtblockgc;
 // pmtblock GC를 위한 free block
 // updatelog GC Power off 처리와 동일하게 GC 처음과 마지막에 context를 저장한다.
 // PBT와 마찬가지로 최대 16개의 valid page copy가 발생할 수 있다.
 // GC 시에 발생하는 valid page copy를 줄이려면 PMT Block의 개수를 늘리면 된다.
 // 8Byte

 unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT];
 // 16GB 기준, 8KB NAND Page(Page mapping 하나에 4Byte 사용, 2097152 중에 하나의 위치)시에 1024(=2097152/2048)개의 Valid Page로 pmtblock에 저장됨.
 // 4 * 1024 = 4096Byte : SRAM Cache Size, PMT_MAX_VALID_PAGE_COUNT * 4 Byte이므로,
 // overprovision은 기존 eMMC와 SSD의 실험에서 5%로 설정하므로, SPFTL의 실험에서 5%로 설정한다.
 // overprovision 영역이 클수록 performance 향상에 도움을 준다.
 // reference) An Analytical Model of eMMC Key Performance Indicators, 2015 IEEE International Memory Workshop (IMW)
 // Anatomy of a Solid-state Drive, Commun. ACM, 2012
 // 16384 전체 블럭에서 820개를 OP로 사용한다.
 // 820 = 85 + 735
 // 85개는 구성이 GXT 2, PBT 2, PMT 79(PB가 GC때에 평균 valid page 13개를 옮기는 기준을 동일하게 적용하면 about 79개의 PMT Block 필요),
 // updateblock 1, freeblockforupdateblockgc 1로 구성된다.
 // 나머지 735개는 user capacity (15564 블럭, 95%)를 제외하고 host data가 write되는 freeblock 블럭.

 unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT];
 // 16GB 기준, 8KB NAND Page, (PB는 6Byte per block (PB), 8192/6 = 1365.33, 1365개 (8190Byte)),
 // 13개(16384/1365 = 12*1365 + 1*4)의 Valid Page로 pbtblock에 저장됨.
 // 4 * 13 = 52Byte

 PMTGCVICTIMS pmtgcvctim;
 // PMT GC의 VICTIM 선정을 위한 구조체

 MINIMUMVALIDPAGECOUNTFORGC gcvctim;
 // GC시에 Valid Page가 가장 작은 PB를 선택하기 위한 정보
 // GC시에 모든 PB를 검색하여, Valid Page가 가장 적은 PB를 선택하는 것은 시간에 부담이 되므로,
 // PBT의 Valid Page 1개 당 최소를 가지는 Index와 해당 PB의 Valid Page Count를 보관함
 // GCVICTIM 104Byte (26(pbaddr, validcnt) * 4)


} CONTEXT;
#pragma pack(pop)
*/
// 2047 bytes

#if ((FTL_TYPE & FTL_SPFTL_MIXED) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#pragma pack(push,1) // or struct __attribute__ ((__packed__))
typedef struct
{
	METALOG uptgxtblk;
	METALOG uptpbtblk;
	METALOG uptpmtblk;
	METALOG sp_uptgxtblk;
	METALOG sp_uptpbtblk;
	METALOG sp_uptpmtblk;
	METAGCBLK metagcblk;	// 26 bytes (from uptgxtblk(7 bytes) to metagcblk(5 bytes))
	METAGCBLK sp_metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT];// 769*2, 1538 bytes, pointers of page maps, pmptr
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT];// 11*2, 22 bytes, pointers of block information, biptr
	unsigned short pmt_log[PMT_MAX_VALID_PAGE_COUNT];// 769*2, 1538 bytes, pointers of page maps, pmptr
	unsigned short pbt_log[PBT_MAX_VALID_PAGE_COUNT];// 11*2, 22 bytes, pointers of block information, biptr
	PMTGCVICTIMS_MIXED pmtgcvctim;//69*6, 414 bytes

	LOG uptblk; // 8 bytes
	GCBLK usrgcblk;// 6 bytes
	MINIMUMVALIDPAGECOUNTFORGC gcvctim;// 11*3, 33 bytes
} CONTEXT;
#pragma pack(pop)
#else
#pragma pack(push,1) // or struct __attribute__ ((__packed__))
typedef struct
{
	METALOG uptgxtblk;
	METALOG uptpbtblk;
	METALOG uptpmtblk;
	METAGCBLK metagcblk;	// 26 bytes (from uptgxtblk(7 bytes) to metagcblk(5 bytes))
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT];// 769*2, 1538 bytes, pointers of page maps, pmptr
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT];// 11*2, 22 bytes, pointers of block information, biptr
	PMTGCVICTIMS pmtgcvctim;//69*6, 414 bytes

	LOG uptblk; // 8 bytes
	GCBLK usrgcblk;// 6 bytes
	MINIMUMVALIDPAGECOUNTFORGC gcvctim;// 11*3, 33 bytes
} CONTEXT;
#pragma pack(pop)
#endif


// SPFTL

#pragma pack(push,1)
typedef struct
{
	LOG uptgxtblk;
	LOG uptpbtblk;
	LOG uptpmtblk;
	LOG uptblk;
	GCBLK usrgcblk;
	GCBLK metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT_SPFTL];
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT_SPFTL];
	PMTGCVICTIMS_SPFTL pmtgcvctim;
	MINIMUMVALIDPAGECOUNTFORGC_SPFTL gcvctim;
} CONTEXT_SPFTL;
#pragma pack(pop)

// End

#pragma pack(push,1)
typedef struct
{
	LOG uptgxtblk;
	LOG uptpbtblk;
	LOG uptpmtblk;
	LOG uptblk;
	GCBLK usrgcblk;
	GCBLK metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT_32GB];
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT_32GB];
	MINIMUMVALIDPAGECOUNTFORGC_32GB gcvctim;
	PMTGCVICTIMS_32GB pmtgcvctim;
} CONTEXT_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	LOG uptgxtblk;
	LOG uptpbtblk;
	LOG uptpmtblk;
	LOG uptblk;
	GCBLK usrgcblk;
	GCBLK metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT_64GB];
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT_64GB];
	MINIMUMVALIDPAGECOUNTFORGC_64GB gcvctim;
	PMTGCVICTIMS_64GB pmtgcvctim;
} CONTEXT_64GB;
#pragma pack(pop)


// SPFTL

#pragma pack(push,1)
typedef struct
{
	LOG uptgxtblk;
	LOG uptpbtblk;
	LOG uptpmtblk;
	LOG uptblk;
	GCBLK usrgcblk;
	GCBLK metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT_SPFTL_32GB];
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT_SPFTL_32GB];
	MINIMUMVALIDPAGECOUNTFORGC_SPFTL_32GB gcvctim;
	PMTGCVICTIMS_SPFTL_32GB pmtgcvctim;
} CONTEXT_SPFTL_32GB;
#pragma pack(pop)

#pragma pack(push,1)
typedef struct
{
	LOG uptgxtblk;
	LOG uptpbtblk;
	LOG uptpmtblk;
	LOG uptblk;
	GCBLK usrgcblk;
	GCBLK metagcblk;
	unsigned short pmt[PMT_MAX_VALID_PAGE_COUNT_SPFTL_64GB];
	unsigned short pbt[PBT_MAX_VALID_PAGE_COUNT_SPFTL_64GB];
	MINIMUMVALIDPAGECOUNTFORGC_SPFTL_64GB gcvctim;
	PMTGCVICTIMS_SPFTL_64GB pmtgcvctim;
} CONTEXT_SPFTL_64GB;
#pragma pack(pop)

//end of context
//---------------------------------------------------------------------------------------


// Baseline FTL Initial Block Layout Pre-BaseLie FTL
//
//==============================================
// 0    GXT Block
//==============================================
// 1    freeblockforgxtgc
//==============================================
// 2    pbtblock
//==============================================
// 3    freeblockforpbtblockgc
//==============================================
// 4 ~ 80   pmtblock 1 ~ 77 valid page ratio 769/11 69 block
//==============================================
// 81    updatepmtblock
//==============================================
// 82    freeblocforupdatepmtblockgc
//==============================================
// 83    updateblock
//==============================================
// 84    freeblockforupdateblockgc
//==============================================
// 85 ~ 16383  free blocks and data blocks
//                  (735 + 15564 = 16299)
//==============================================
//

// SPFTL Mixed
//
//==============================================
// 0    GXT Block
//==============================================
// 1    freeblockforgxtgc
//==============================================
// 2    sp GXT Block
//==============================================
// 3    pbtblock
//==============================================
// 4    sp pbtblock
//==============================================
// 5    freeblockforpbtblockgc
//==============================================
// 6 ~ 78   pmtblock 1 ~ 73  valid page ratio 769/11 / 2 + 1-> pmt 769/11 /2 -> pmt sp
//==============================================
// 79    updatepmtblock
//==============================================
// 80    sp updatepmtblock
//==============================================
// 81    freeblocforupdatepmtblockgc
//==============================================
// 82    sp freeblockforgc
//==============================================
// 83    updateblock
//==============================================
// 84    freeblockforupdateblockgc
//==============================================
// 85 ~ 16383  free blocks and data blocks
//                  (735 + 15564 = 16299)
//==============================================
//

// Baseline/SPFTL Initial Block Layout 16GB (8K page, 128 pages per block)
//
//==============================================
// 0    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 1    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 2    uptgxtblk ( cxt store )
//==============================================
// 3    uptpbtblk ( block information store, valid page 11개 (16GB 기준, 16384 / 1638(==8192/5, 8KB page / pb unit)) )
//==============================================
// 4    uptpmtblk ( page maps )
//==============================================
// 5 ~ 73   pmtblks ( page maps )
//        (uptpbtblk의 valid page 11개 동일 기준으로 69개의  block으로 구성, (769/11, 16GB 기준, page maps/valid pages of uptpbtblk) )
//==============================================
// 74   metagcblk ( gc for uptgxtblk, uptpbtblk, uptpmtblk )
//==============================================
// 75    uptblk ( user data write )
//==============================================
// 76    usrgcblk ( gc for uptblk )
//==============================================
// 77 ~ 16383  free blocks and user data blocks
//                  over provision total = 820개 (5% Over provision,16384 total)
//                   - free blocks = 743개
//                   - other block = 77 개
//                   - user density block  = 15564
//                    - (743(820(5%) - 77(numofother)) + 15564 = 16307)
//==============================================
//

// SPFTL Mixed Initial Block Layout 16GB (8K page, 128 pages per block)
//
//==============================================
// 0    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 1    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 2    uptgxtblk ( cxt store )
//==============================================
// 3    uptpbtblk ( block information store, valid page 11개 (16GB 기준, 16384 / 1638(==8192/5, 8KB page / pb unit)) )
//==============================================
// 4    uptpmtblk ( page maps )
//==============================================
// 5    sp_uptgxtblk ( cxt store )
//==============================================
// 6    sp_uptpbtblk ( block information store, valid page 11개 (16GB 기준, 16384 / 1638(==8192/5, 8KB page / pb unit)) )
//==============================================
// 7    sp_uptpmtblk ( page maps )
//==============================================
// 8 ~ 72   pmtblks ( page maps )
//        (32 page and 32 subpage blocks)
//==============================================
// 73   sp_metagcblk ( sp gc for uptgxtblk, uptpbtblk, uptpmtblk )
//==============================================
// 74   metagcblk ( gc for uptgxtblk, uptpbtblk, uptpmtblk )
//==============================================
// 75    uptblk ( user data write )
//==============================================
// 76    usrgcblk ( gc for uptblk )
//==============================================
// 77 ~ 16383  free blocks and user data blocks
//                  over provision total = 820개 (5% Over provision,16384 total)
//                   - free blocks = 743개
//                   - other block = 77 개
//                   - user density block  = 15564
//                    - (743(820(5%) - 77(numofother)) + 15564 = 16307)
//==============================================
//

// Baseline/SPFTL Initial Block Layout 32GB (8K page, 128 pages per block)
//
//==============================================
// 0    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 1    gxtpointerblock ( quickly looking for CXT in all meta blocks )
//==============================================
// 2    uptgxtblk ( cxt store )
//==============================================
// 3    uptpbtblk ( block information store, valid page 21개 (32GB 기준, 32768 / 1638(==8192/5, 8KB page / pb unit)) )
//==============================================
// 4    uptpmtblk ( page maps )
//==============================================
// 5 ~ 77   pmtblks ( page maps )
//        (uptpbtblk의 valid page 21개 동일 기준으로 73개의  block으로 구성, (1537/21, 32GB 기준, page maps/valid pages of uptpbtblk) )
//==============================================
// 78   metagcblk ( gc for uptgxtblk, uptpbtblk, uptpmtblk )
//==============================================
// 79    uptblk ( user data write )
//==============================================
// 80    usrgcblk ( gc for uptblk )
//==============================================
// 81 ~ 32767  free blocks and user data blocks
//                  over provision total = 1639개 (5% Over provision,32768 total)
//                   - free blocks = 1558개
//                   - other block = 81 개
//                   - user density block  = 31129
//==============================================
//

#if (FTL_TYPE & FTL_16GB)
#define UPDATE_GC_BLOCK_INIT		(2)
#define UPDATE_PBT_BLOCK_INIT		(3)
#define UPDATE_PMT_BLOCK_INIT		(4)

#if ((FTL_TYPE & FTL_SPFTL_MIXED) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#define SP_UPDATE_GC_BLOCK_INIT			(5)
#define SP_UPDATE_PBT_BLOCK_INIT		(6)
#define SP_UPDATE_PMT_BLOCK_INIT		(7)
#define SP_FREE_BLOCK_FOR_META_BLOCK_GC_INIT (73)
#endif


#if (FTL_TYPE & FTL_SPFTL_2KB)
#define FREE_BLOCK_FOR_META_BLOCK_GC_INIT (105)
#define UPDATE_BLOCK_INIT        (106)
#define FREE_BLOCK_FOR_UPDATE_BLOCK_GC_INIT   (107)
#else
#define FREE_BLOCK_FOR_META_BLOCK_GC_INIT (74)
#define UPDATE_BLOCK_INIT        (75)
#define FREE_BLOCK_FOR_UPDATE_BLOCK_GC_INIT   (76)
#endif

#if ((FTL_TYPE & FTL_SPFTL_MIXED) || (FTL_TYPE & FTL_SPFTL_LOGGING))
#define PMT_BLOCK_START         (8)
//#define PMT_BLOCK_COUNT			(32)		// 16GB Case
#define PMT_BLOCK_COUNT			(48)		// 16GB Case
#else
#define PMT_BLOCK_START         (5)
// Baseline과 SPFTL은 동일한 Block layout을 사용하길 원한다.
// PMT Block 개수를 Density에 따라 동일하게 한다.
#if (FTL_TYPE & FTL_SPFTL_2KB)
#define PMT_BLOCK_COUNT			(100)		// 16GB Case
#else
#define PMT_BLOCK_COUNT			(PMT_MAX_VALID_PAGE_COUNT_16GB/PBT_MAX_VALID_PAGE_COUNT_16GB)		// 16GB Case
#endif
#endif

#if (FTL_TYPE & FTL_SPFTL_2KB)
#define DATA_BLOCK_START        (108)
#else
#define DATA_BLOCK_START        (77)
#endif
#define DATA_BLOCK_COUNT        (15564)
#define PB_SECTOR_COUNT         (2048)
#if (FTL_TYPE & FTL_BASELINE_EXT)
#define MAX_META_PM_ADDR		(DATA_BLOCK_START*NAND_PAGES_PER_BLOCK*2)
#else
#define MAX_META_PM_ADDR		(DATA_BLOCK_START*NAND_PAGES_PER_BLOCK)
#endif
#if (FTL_TYPE & FTL_SPFTL_2KB)
#define META_BLOCK_END			(105)
#define OP_USR_FB_COUNT			(712)
#else
#define META_BLOCK_END			(74)
#define OP_USR_FB_COUNT			(743)
#endif
#elif (FTL_TYPE & FTL_32GB)
#define UPDATE_GC_BLOCK_INIT		(2)
#define UPDATE_PBT_BLOCK_INIT		(3)
#define UPDATE_PMT_BLOCK_INIT		(4)
#define FREE_BLOCK_FOR_META_BLOCK_GC_INIT (78)
#define UPDATE_BLOCK_INIT        (79)
#define FREE_BLOCK_FOR_UPDATE_BLOCK_GC_INIT   (80)
#define PMT_BLOCK_START         (5)
#define PMT_BLOCK_COUNT			(PMT_MAX_VALID_PAGE_COUNT_32GB/PBT_MAX_VALID_PAGE_COUNT_32GB)
#define DATA_BLOCK_START        (81)
#define DATA_BLOCK_COUNT        (31129)
#define PB_SECTOR_COUNT         (2048)
#define MAX_META_PM_ADDR		(DATA_BLOCK_START*NAND_PAGES_PER_BLOCK)
#define META_BLOCK_END			(78)
#define OP_USR_FB_COUNT			(1558)
#endif


#pragma pack(push,1)
typedef struct
{
 PB physicalblocks[PB_COUNT_PER_VALID_PAGE];
} PBTPERVALIDPAGE;
#pragma pack(pop)

//#define LPN_COUNT_PER_VALID_PAGE      (2048)  // 8KB NAND Page일 경우, 4Byte Per LPN

//end of layout
//---------------------------------------------------------------------------------------

//#define MAX_PMT_PAGE_COUNT                          (2097152)

#define DBG_ASSERT(x)   do                  \
        {                   \
         if (!(x))               \
                  {        \
          fprintf(stderr, "DBG Assert : (%s, %d)\n", __FILE__, __LINE__); \
          *(volatile int*)0 = 0;           \
                  }        \
        } while (0)

typedef struct
{
 unsigned int host_sectors;
 unsigned int meta_page_count;
 unsigned int meta_ftl_context_count;
 unsigned int meta_ftl_context_count_8;
 unsigned int meta_ftl_context_count_4;
 unsigned int meta_ftl_context_erase_8;
 unsigned int meta_ftl_context_erase_4;

 unsigned int meta_ftl_0_block_erase;
 unsigned int meta_ftl_1_block_erase;
 unsigned int meta_ftl_0_block_write_page_count;
 unsigned int meta_ftl_1_block_write_page_count;

 unsigned int meta_sub_page_context_count;
 unsigned int meta_other_sub_page_context_count;

 unsigned int meta_context_valid;
 unsigned int meta_context_valid_4;
 unsigned int meta_block_valid;   // valid page copy
 unsigned int meta_block_valid_4;
 unsigned int meta_page_valid;   // valid page copy
 unsigned int meta_page_valid_4;

 unsigned int meta_page_map_count;
 unsigned int meta_page_map_count_8;
 unsigned int meta_page_map_count_4;
 unsigned int meta_page_map_erase_4;
 unsigned int meta_page_map_erase_8;
 unsigned int meta_block_info_count;
 unsigned int meta_block_info_count_8;
 unsigned int meta_block_info_count_4;
 unsigned int meta_block_info_erase_4;
 unsigned int meta_block_info_erase_8;
 unsigned int compaction_page_count;

 unsigned int lpn_req_cnt;
 unsigned int lpn_cache_hit;

 unsigned int global_cxt_min_diff_bytes;
 unsigned int global_cxt_max_diff_bytes;
 unsigned int global_cxt_avg_diff_bytes;
 unsigned int global_cxt_store_cnt;

 unsigned int block_map_min_diff_bytes;
 unsigned int block_map_max_diff_bytes;
 unsigned int block_map_avg_diff_bytes;
 unsigned int block_map_store_cnt;

 unsigned int page_map_min_diff_bytes;
 unsigned int page_map_max_diff_bytes;
 unsigned int page_map_avg_diff_bytes;
 unsigned int page_map_store_cnt;

 unsigned int user_block_8;
 unsigned int user_block_4;

 unsigned int compaction_page_8;
 unsigned int compaction_page_4;

 unsigned int host_pages;

 unsigned int num_pbt_gc_cnt;
 unsigned int num_pmt_gc_cnt;
 unsigned int num_gxt_gc_cnt;

 unsigned int num_usr_gc_cnt;

 unsigned int usr_page_cnt;
 unsigned int usr_gc_page_cnt;

 unsigned int nand_tR;
 unsigned int nand_tProg;
 unsigned int nand_tErase;
 unsigned int nand_tDMA;

 unsigned int aged;
 unsigned int lpn_check_group[3];

} STATISTICS;

// 5 Bytes
// 변경된 PMT를 Logging 하기 위한 단위 구조체
#pragma pack(push,1)
typedef struct
{
 USRLPNDESC ppn;
 unsigned short m_lpn;
} MLP2UNIT;
#pragma pack(pop)

#pragma pack(push,1)
// 4096Byte
// 변경된 PMT를 4KB에 전체적으로 저장하기 위한 구조체
#define MAX_PMT_LOG_UPT_CNT		(818)
typedef struct
{
	MLP2UNIT tong[MAX_PMT_LOG_UPT_CNT];			// 818 * 5 = 4090
	unsigned short page_map_count;	// (4096 - 2) / MLP2UNIT size
} DIFFCACHEPMT;
#pragma pack(pop)

typedef struct
{
	unsigned int erase_count;				// writable block과 마찬 가지로 erase count최상위 bit을 4kb, 8kb로 구분
	unsigned char valid_page_count;
	unsigned char valid_bitmap;
	unsigned short block_index_for_log;
} DB;
// 4096Byte Under
// 변경된 PBT를 4KB에 전체적으로 저장하기 위한 구조체
typedef struct
{
 unsigned int block_map_count;
 unsigned int dummy;
 DB blockinfo_blocks[511];		// 2555 Bytes
} DIFFCACHEBLOCK;

typedef struct
{
	unsigned int global_cxt_count;
} GLOBALCXTLOCCNT;
typedef struct
{
	unsigned int locations;
	unsigned short index;
	unsigned char type;
} DIFFANYLOCS;
typedef struct
{
	unsigned char type;
	unsigned char index;
	LOG log;
} DIFFANYLOGS;
#define CONTEXT_LOG_WRITABLE_BLOCKS		(0)
#define CONTEXT_FREE_BLOCK_FOR_GC		(1)
#define CONTEXT_PMT_BLOCKS_8			(2)
#define CONTEXT_PMT_BLOCKS_4			(3)
#define CONTEXT_BMT_BLOCKS_8			(4)
#define CONTEXT_BMT_BLOCKS_4			(5)
#define CONTEXT_PAGE_GROUP_LOCATIONS_8		(6)
#define CONTEXT_PAGE_GROUP_LOCATIONS_4		(7)
#define CONTEXT_BLOCK_GROUP_LOCATIONS_8		(8)
#define CONTEXT_BLOCK_GROUP_LOCATIONS_4		(9)
#define CONTEXT_PB							(10)
#define CONTEXT_BLOCK_VICTIM				(11)
#define CONTEXT_BLOCK_VICTIM_VALID			(12)
#define CONTEXT_FREE_METABLOCK_FOR_GC		(13)


// under 4KB
typedef struct
{
	unsigned char log_cnt;			// 1 Byte
	DIFFANYLOGS diff_logs[225];		// 1920 Byte

	unsigned char loc_cnt;			// 1 Byte
	DIFFANYLOCS diff_loc[225];      // 1344 Byte

} DIFFGLOBALCXT;
void add_diff_logs(unsigned int index, LOG* plog, unsigned int type);
void add_diff_locs(unsigned int index, unsigned int value, unsigned int type);

//end of structure
//---------------------------------------------------------------------------------------

#define CHECK_VALID_COUNT        (1)       // for compaction validataion check
#define IDX_EMPTY          (-1)
#define PBT_CACHE_VICTIM_DEFAULT_IDX     (0)
#define PMT_CACHE_VICTIM_DEFAULT_IDX     (0)
#define TERMINATED_VALID_PAGE_COUNT      (255)
#define PBT_NO_STORE         (0)
#define PBT_STORE          (1)
#define INF_VALID_PAGE_COUNT       (1024)

void ftl_init(void);
void ftl_close(void);
int ftl_write(unsigned int sector_addr, unsigned int sector_count);
int ftl_read(unsigned int sector_addr, unsigned int sector_count);

int _load_data_block_info(unsigned int physicalblockaddr);
int _change_pbt_block_by_gc(METALOG *p_pbtblock, int selected_pbrowindex);
int __store_data_block_info(int pbrowindex);
int _flush_lpn(void);
int _flush_pbt(void);
int _load_page_map(unsigned int rcv_sector_addr);
#if (FTL_TYPE & FTL_BASELINE_EXT)
int _change_pmt_block_by_gc(unsigned int selected_page_group_index, unsigned int selected_page_group_index2);
int __store_page_map(unsigned int selected_page_group_index, unsigned int selected_page_group_index2);
#else
int _change_pmt_block_by_gc(unsigned int selected_page_group_index);
int __store_page_map(unsigned int selected_page_group_index);
#endif
int _store_ftl_context(void);
int _compact_log_block(void);
int _check_update_block(void);
int _get_update_log_by_gc(void);
void _update_min_db_valid_count(int physicalblockaddr, int validpagecount, int erasecount, int isstore);

#endif /* INC_SPFTL_H_ */
